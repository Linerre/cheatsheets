\section*{Goals of Virtual Memory (VM) system}
\begin{enumerate}
\item \textbf{transparency} invisible to running prog (illusion: private ph. mem)
\item \textbf{efficiency} OS needs hardware support (e.g. TLBs)
  \begin{itemize}
  \item time (not making programs run much more slowly)
  \item space (not using too much mem for structs to support virtualization)
  \end{itemize}
\item \textbf{protection} thus enables isolation among processes
\end{enumerate}
\section*{Address Translation (hardware-based)}
\begin{minipage}{\linewidth}
  \centering
  \texttt{physical address = virtual address + base}
\end{minipage}
\begin{minipage}{0.45\linewidth}
  \begin{enumerate}
  \item Each memory reference by a process is a virtual address
  \item isolation property is satisfied (security)
  \item translation and check are cheap (performance)
  \end{enumerate}
\end{minipage}
\begin{minipage}{.5\linewidth}
  \begin{lstlisting}[language=c,xleftmargin=2pt]
if (addr < bounds)
  return *(base + addr);
else
  throw new SegFaultException;
// Waste physical mem (must alloc all)
// No (easy) sharing btw procs
\end{lstlisting}
\end{minipage}

\section*{Dynamic Relocation: Hardware Requirements}
\begin{tabular}[th!]{p{3.5cm}p{5.4cm}}
  Hardware Requirements & Notes \\
  \hline
  Privileged mode & Needed to prevent user-mode processes from executing privileged operations \\
  \hline
  Base/bounds registers & Need pair of registers per CPU to support address translation and bounds checks \\
  \hline
  Able to translate virtual addr and check bounds & Circuitry to do translations and check limits; in this case, quite simple\\
  \hline
  Privileged instructions to update base/bounds & OS must be ablt to set these values before letting a user program run \\
  \hline
  Privileged instructions to register exception handlers & OS must be able to tell hardware what code to run if exception occurs \\
  \hline
  Able to raise exceptions & When processes try to access privileged instructions or out-of-bounds memory \\
  \hline
\end{tabular}
\section*{Hardware support in base/bounds virtual memory}
\begin{enumerate}
\item provide 2 different CPU modes
  \begin{itemize}
  \item privileged mode (kernel mode) to access entire machine
  \item user mode (limited direction execution)
  \item a single bit stored in processor status word indicating current mode
  \end{itemize}
\item provide base and bounds registers (MMU)
\item provide \textbf{privileged} instructions to modify the base/bounds registers
\item provide exception handler to handle exceptions generated by CPU
  \begin{itemize}
  \item CPU should stop executing user program and raise exception
  \item CPU should be able to inform OS of handlers location (privileged)
  \end{itemize}
\end{enumerate}
\section*{Dynamic Relocation: Hardware Requirements}
\begin{tabular}[th!]{p{3cm}p{6cm}}
  OS Requirements & Notes \\
  \hline
  Memory management & \parbox[t]{6cm}{Need to allocate memory for new processes\\
  Reclaim memory from terminated processes \\
  Generally manage memory via \textbf{free list}} \\
  \hline
  Base/bounds management & Must set base/bounds properly on context switch\\
  \hline
  Exception handling  & \parbox[t]{6cm}{Code to run when exception arise\\
  liley action is to terminate offending process} \\
  \hline
\end{tabular}
\section*{OS support in base/bounds virtual memory}
\begin{enumerate}
\item when a process is created, finding space for its addr space in memory
\item when a process is terminated (exits gracefully or forcefully killed), reclaiming all of its memory (putting back to free list).
\item when a context switch occurs, performing a few additional steps: save and restore base-and-bounds pair to memory in process structure or process control block (PCB)
\item must provide exception handlers
\end{enumerate}
